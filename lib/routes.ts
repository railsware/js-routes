/*
File generated by js-routes RubyVariables.GEM_VERSION
Based on Rails RubyVariables.RAILS_VERSION routes of RubyVariables.APP_CLASS
 */

type RouteParameter = any;
type RouteParameters = Record<string, RouteParameter>;
type Serializer = (object: any) => string;
type RouteHelper = {
  (...args: RouteParameter[]): string;
  required_params: string[];
  toString(): string;
};

type RouteHelpers = Record<string, RouteHelper>;

declare const RubyVariables: {
  PREFIX: string;
  DEPRECATED_GLOBBING_BEHAVIOR: boolean;
  SPECIAL_OPTIONS_KEY: string;
  DEFAULT_URL_OPTIONS: RouteParameters;
  SERIALIZER: Serializer;
  NAMESPACE: string;
  ROUTES: RouteHelpers
};

declare const exports: any;
declare const define:
  | undefined
  | (Function & { amd?: (args: any[], callback: () => any) => void });

type Configuration = {
  prefix: string;
  default_url_options: RouteParameters;
  special_options_key: string;
  serializer?: Serializer;
};

type Optional<T> = { [P in keyof T]?: T[P] | null };
type RouterExposedMethods = {
  config(): Configuration,
  configure(arg: Partial<Configuration>): Configuration,
  default_serializer: Serializer,
};

(function (that: any): RouterExposedMethods {
  enum NodeTypes {
    GROUP = 1,
    CAT = 2,
    SYMBOL = 3,
    OR = 4,
    STAR = 5,
    LITERAL = 6,
    SLASH = 7,
    DOT = 8,
  }
  type RouteTree =
    | [NodeTypes.GROUP, RouteTree, never]
    | [NodeTypes.STAR, RouteTree, never]
    | [NodeTypes.LITERAL, string, never]
    | [NodeTypes.SLASH, "/", never]
    | [NodeTypes.DOT, ".", never]
    | [NodeTypes.CAT, RouteTree, RouteTree]
    | [NodeTypes.SYMBOL, string, never];

  const Root = typeof exports === "object" ? exports : that;

  class ParameterMissing extends Error {
    constructor(message: string) {
      super(message);
      Object.setPrototypeOf(this, Object.getPrototypeOf(this));
    }
  }

  const DeprecatedGlobbingBehavior = RubyVariables.DEPRECATED_GLOBBING_BEHAVIOR;

  const SpecialOptionsKey = RubyVariables.SPECIAL_OPTIONS_KEY;

  const UriEncoderSegmentRegex = /[^a-zA-Z0-9\-\._~!\$&'\(\)\*\+,;=:@]/g;

  const ReservedOptions = [
    "anchor",
    "trailing_slash",
    "subdomain",
    "host",
    "port",
    "protocol",
  ] as const;

  const DefaultConfiguration: Configuration = {
    prefix: RubyVariables.PREFIX,
    default_url_options: RubyVariables.DEFAULT_URL_OPTIONS,
    special_options_key: RubyVariables.SPECIAL_OPTIONS_KEY,
    serializer: RubyVariables.SERIALIZER,
  };

  class UtilsClass {
    configuration: Configuration = DefaultConfiguration;

    default_serializer(object: any, prefix?: string | null): string {
      if (object == null) {
        return "";
      }
      if (!prefix && !(this.get_object_type(object) === "object")) {
        throw new Error("Url parameters should be a javascript hash");
      }
      const result: string[] = [];
      switch (this.get_object_type(object)) {
        case "array":
          for (const element of object) {
            result.push(this.default_serializer(element, prefix + "[]"));
          }
          break;
        case "object":
          for (let key in object) {
            if (!object.hasOwnProperty(key)) continue;
            let prop = object[key];
            if (prop == null && prefix) {
              prop = "";
            }
            if (prop != null) {
              if (prefix) {
                key = prefix + "[" + key + "]";
              }
              result.push(this.default_serializer(prop, key));
            }
          }
          break;
        default:
          if (object != null) {
            result.push(
              encodeURIComponent(prefix!.toString()) +
                "=" +
                encodeURIComponent(object.toString())
            );
          }
      }
      return result.join("&");
    }

    serialize(object: any): string {
      const custom_serializer = this.configuration.serializer;
      if (custom_serializer) {
        return custom_serializer(object);
      } else {
        return this.default_serializer(object);
      }
    }

    extract_options(number_of_params: number, args: object[]): RouteParameters {
      const last_el = args[args.length - 1];
      if (
        (args.length > number_of_params && last_el === void 0) ||
        (last_el != null &&
          "object" === this.get_object_type(last_el) &&
          !this.looks_like_serialized_model(last_el))
      ) {
        const options: RouteParameters = args.pop() || {};
        delete options[this.configuration.special_options_key];
        return options;
      } else {
        return {};
      }
    }

    looks_like_serialized_model(
      object: any
    ): object is { id: any } | { to_param: any } {
      return (
        !object[this.configuration.special_options_key] &&
        ("id" in object || "to_param" in object)
      );
    }

    path_identifier(
      object: 0 | Record<string, any> | { toString(): string }
    ): string {
      if (object === 0) {
        return "0";
      }
      if (!object) {
        return "";
      }
      let result: any = object;
      if (this.get_object_type(object) === "object") {
        if ("to_param" in object) {
          if (object.to_param == null) {
            throw new ParameterMissing("Route parameter missing: to_param");
          }
          result = object.to_param;
        } else if ("id" in object) {
          if (object.id == null) {
            throw new ParameterMissing("Route parameter missing: id");
          }
          result = object.id;
        } else {
          result = object;
        }
        if (this.get_object_type(result) === "function") {
          result = result.call(object);
        }
      }
      return result.toString();
    }

    normalize_options(
      parts: string[],
      required_parts: string[],
      default_options: RouteParameters,
      call_arguments: RouteParameter[]
    ) {
      call_arguments = [...call_arguments];
      let options = this.extract_options(parts.length, call_arguments);
      if (call_arguments.length > parts.length) {
        throw new Error("Too many parameters provided for path");
      }
      let use_all_parts = call_arguments.length > required_parts.length;
      const parts_options: RouteParameters = {};
      for (const key in options) {
        const value = options[key];
        if (!options.hasOwnProperty(key)) continue;
        use_all_parts = true;
        if (parts.includes(key)) {
          parts_options[key] = value;
        }
      }
      options = {
        ...this.configuration.default_url_options,
        ...default_options,
        ...options,
      };
      const result: RouteParameters = {};
      const url_parameters: RouteParameters = {};
      result["url_parameters"] = url_parameters;
      for (const key in options) {
        if (!options.hasOwnProperty(key)) continue;
        const value = options[key];
        if (ReservedOptions.includes(key as any)) {
          result[key] = value;
        } else {
          url_parameters[key] = value;
        }
      }
      const route_parts = use_all_parts ? parts : required_parts;
      let i = 0;
      for (const part of route_parts) {
        if (i < call_arguments.length) {
          if (!parts_options.hasOwnProperty(part)) {
            url_parameters[part] = call_arguments[i];
            ++i;
          }
        }
      }
      return result;
    }
    build_route(
      parts: string[],
      required_parts: string[],
      default_options: RouteParameters,
      route: RouteTree,
      full_url: boolean,
      args: RouteParameter[]
    ): string {
      const options = this.normalize_options(
        parts,
        required_parts,
        default_options,
        args
      );
      const parameters = options["url_parameters"];
      let result = this.get_prefix() + this.visit(route, parameters);
      if (options["trailing_slash"] === true) {
        result = result.replace(/(.*?)[\/]?$/, "$1/");
      }
      const url_params = this.serialize(parameters);
      if (url_params.length) {
        result += "?" + url_params;
      }
      result += options.anchor ? "#" + options.anchor : "";
      if (full_url) {
        result = this.route_url(options) + result;
      }
      return result;
    }
    visit(
      route: RouteTree,
      parameters: RouteParameters,
      optional: boolean = false
    ): string {
      switch (route[0]) {
        case NodeTypes.GROUP:
          return this.visit(route[1], parameters, true);
        case NodeTypes.STAR:
          return this.visit_globbing(route[1], parameters, true);
        case NodeTypes.LITERAL:
        case NodeTypes.SLASH:
        case NodeTypes.DOT:
          return route[1];
        case NodeTypes.CAT:
          const [_, left, right] = route;
          const left_part = this.visit(left, parameters, optional);
          const right_part = this.visit(right, parameters, optional);
          if (
            optional &&
            ((this.is_optional_node(left[0]) && !left_part) ||
              (this.is_optional_node(right[0]) && !right_part))
          ) {
            return "";
          }
          return left_part + right_part;
        case NodeTypes.SYMBOL:
          const key = route[1];
          const value = parameters[key];
          delete parameters[key];
          if (value != null) {
            return this.encode_segment(this.path_identifier(value));
          }
          if (optional) {
            return "";
          } else {
            throw new ParameterMissing("Route parameter missing: " + key);
          }
          break;
        default:
          throw new Error("Unknown Rails node type");
      }
    }
    encode_segment(segment: string): string {
      return segment.replace(UriEncoderSegmentRegex, function (str) {
        return encodeURIComponent(str);
      });
    }
    is_optional_node(node: NodeTypes): boolean {
      return (
        [NodeTypes.STAR, NodeTypes.SYMBOL, NodeTypes.CAT].includes(node)
      );
    }
    build_path_spec(route: RouteTree, wildcard: boolean = false): string {
      switch (route[0]) {
        case NodeTypes.GROUP:
          return "(" + this.build_path_spec(route[1]) + ")";
        case NodeTypes.CAT:
          return (
            this.build_path_spec(route[1]) + this.build_path_spec(route[2])
          );
        case NodeTypes.STAR:
          return this.build_path_spec(route[1], true);
        case NodeTypes.SYMBOL:
          const key = route[1];
          if (wildcard === true) {
            return (key.startsWith("*") ? "" : "*") + key;
          } else {
            return ":" + key;
          }
          break;
        case NodeTypes.SLASH:
        case NodeTypes.DOT:
        case NodeTypes.LITERAL:
          return route[1];
        default:
          throw new Error("Unknown Rails node type");
      }
    }
    visit_globbing(
      route: RouteTree,
      parameters: RouteParameters,
      optional: boolean
    ): string {
      const key = route[1] as string;
      let value = parameters[key];
      delete parameters[key];
      if (value == null) {
        return this.visit(route, parameters, optional);
      }
      if (this.get_object_type(value) === "array") {
        value = value.join("/");
      }
      if (DeprecatedGlobbingBehavior) {
        return this.path_identifier(value);
      } else {
        return encodeURI(this.path_identifier(value));
      }
    }

    get_prefix(): string {
      const prefix = this.configuration.prefix;
        return prefix.match("/$") ? prefix.substring(0, prefix.length - 1) : prefix;
    }

    route(
      parts_table: [string, boolean][],
      default_options: RouteParameters,
      route_spec: RouteTree,
      full_url: boolean
    ): RouteHelper {
      const required_parts: string[] = [];
      const parts: string[] = [];
      for (const [part, required] of parts_table) {
        parts.push(part);
        if (required) {
          required_parts.push(part);
        }
      }
      const result = (...args: RouteParameter[]): string => {
        return this.build_route(
          parts,
          required_parts,
          default_options,
          route_spec,
          full_url,
          args
        );
      };
      result.required_params = required_parts;
      result.toString = () => {
        return this.build_path_spec(route_spec);
      };
      return result;
    }
    route_url(
      route_defaults: Optional<{
        host: string;
        protocol: string;
        subdomain: string;
        port: string;
      }>
    ): string {
      const hostname = route_defaults.host || this.current_host();
      if (!hostname) {
        return "";
      }
      const subdomain = route_defaults.subdomain
        ? route_defaults.subdomain + "."
        : "";
      const protocol = route_defaults.protocol || this.current_protocol();
      let port =
        route_defaults.port ||
        (!route_defaults.host ? this.current_port() : undefined);
      port = port ? ":" + port : "";
      return protocol + "://" + subdomain + hostname + port;
    }

    has_location(): boolean {
      return (
        typeof window !== "undefined" && window !== null && !!window.location
      );
    }
    current_host(): string | null {
      if (this.has_location()) {
        return window.location.hostname;
      } else {
        return null;
      }
    }
    current_protocol(): string {
      if (this.has_location() && window.location.protocol !== "") {
        return window.location.protocol.replace(/:$/, "");
      } else {
        return "http";
      }
    }
    current_port(): string {
      if (this.has_location() && window.location.port !== "") {
        return window.location.port;
      } else {
        return "";
      }
    }
    _classToTypeCache: Record<
      string,
      string
    > = "Boolean Number String Function Array Date RegExp Object Error"
      .split(" ")
      .reduce(
        (result, name) => ({
          ...result,
          [`[object ${name}]`]: name.toLowerCase(),
        }),
        {}
      );

    get_object_type(obj: any): string {
      if (obj == null) {
        return "" + obj;
      }
      if (typeof obj === "object" || typeof obj === "function") {
        return (
          this._classToTypeCache[Object.prototype.toString.call(obj)] ||
          "object"
        );
      } else {
        return typeof obj;
      }
    }

    namespace(
      object: any,
      namespace: string | null | undefined,
      routes: unknown
    ): unknown {
      const parts = namespace ? namespace.split(".") : [];
      if (parts.length === 0) {
        return routes;
      }
      for (let index = 0; index < parts.length; index++) {
        const part = parts[index];
        if (index < parts.length - 1) {
          object = object[part] || (object[part] = {});
        } else {
          return (object[part] = routes);
        }
      }
    }

    configure(new_config: Partial<Configuration>): Configuration {
      this.configuration = { ...this.configuration, ...new_config };
      return this.configuration;
    }

    config(): Configuration {
      return { ...this.configuration };
    }
    make(): RouterExposedMethods {
      const routes = {
        ...RubyVariables.ROUTES,
        configure: (config: Partial<Configuration>) => {
          return this.configure(config);
        },
        config: () => {
          return this.config();
        },
        default_serializer: (object: object) => {
          return this.default_serializer(object);
        },
      };
      this.namespace(Root, RubyVariables.NAMESPACE, routes);
      return Object.assign(
        {
          default: routes,
        },
        routes
      );
    }
  }

  const Utils = new UtilsClass();
  const result = Utils.make();

  if (typeof define === "function" && define.amd) {
    define([], function () {
      return result;
    });
  }

  return result;
})(this);
