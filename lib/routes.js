(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.NAMESPACE = factory());
}(this, (function () { 'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  /* @preserve
  File generated by js-routes GEM_VERSION
  Based on Rails routes of APP_CLASS
  */
  var ParameterMissing = function ParameterMissing(message, fileName, lineNumber) {
    var instance = new Error(message, fileName, lineNumber);
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    } else {
      instance.__proto__ = this.__proto__;
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(instance, ParameterMissing);
    }
    return instance;
  };
  ParameterMissing.prototype = Object.create(Error.prototype, { constructor: {
      value: Error,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ParameterMissing, Error);
  } else {
    ParameterMissing.__proto__ = Error;
  }
  var NodeTypes = NODE_TYPES;
  var DeprecatedBehavior = DEPRECATED_BEHAVIOR;
  var ReservedOptions = ['anchor', 'trailing_slash', 'subdomain', 'host', 'port', 'protocol'];
  var Utils = {
    configuration: {
      prefix: PREFIX,
      default_url_options: DEFAULT_URL_OPTIONS,
      special_options_key: SPECIAL_OPTIONS_KEY,
      serializer: SERIALIZER
    },
    default_serializer: function default_serializer(object) {
      var _this = this;
      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (object == null) {
        return "";
      }
      if (!prefix && !(this.get_object_type(object) === "object")) {
        throw new Error("Url parameters should be a javascript hash");
      }
      var s = [];
      switch (this.get_object_type(object)) {
        case "array":
          for (var i = 0; i < object.length; i++) {
            var element = object[i];
            s.push(this.default_serializer(element, prefix + "[]"));
          }
          break;
        case "object":
          Object.keys(object).forEach(function (key) {
            var prop = object[key];
            if (prop == null && prefix != null) {
              prop = "";
            }
            if (prop != null) {
              if (prefix != null) {
                key = prefix + '[' + key + ']';
              }
              s.push(_this.default_serializer(prop, key));
            }
          });
          break;
        default:
          if (object != null) {
            s.push(encodeURIComponent(prefix.toString()) + '=' + encodeURIComponent(object.toString()));
          }
      }
      if (!s.length) {
        return "";
      }
      return s.join("&");
    },
    serialize: function serialize(object) {
      var custom_serializer = this.configuration.serializer;
      if (custom_serializer != null && this.get_object_type(custom_serializer) === "function") {
        return custom_serializer(object);
      } else {
        return this.default_serializer(object);
      }
    },
    clean_path: function clean_path(path) {
      path = path.split("://");
      var last_index = path.length - 1;
      path[last_index] = path[last_index].replace(/\/+/g, "/");
      return path.join("://");
    },
    extract_options: function extract_options(number_of_params, args) {
      var last_el = args[args.length - 1];
      if (args.length > number_of_params && last_el === undefined || last_el != null && "object" === this.get_object_type(last_el) && !this.looks_like_serialized_model(last_el)) {
        var options = args.pop() || {};
        delete options[this.configuration.special_options_key];
        return options;
      } else {
        return {};
      }
    },
    looks_like_serialized_model: function looks_like_serialized_model(object) {
      return !object[this.configuration.special_options_key] && ("id" in object || "to_param" in object);
    },
    path_identifier: function path_identifier(object) {
      if (object === 0) {
        return "0";
      }
      if (!object) {
        return "";
      }
      var property = object;
      if (this.get_object_type(object) === "object") {
        if ("to_param" in object) {
          if (object.to_param == null) {
            throw new ParameterMissing("Route parameter missing: to_param");
          }
          property = object.to_param;
        } else if ("id" in object) {
          if (object.id == null) {
            throw new ParameterMissing("Route parameter missing: id");
          }
          property = object.id;
        } else {
          property = object;
        }
        if (this.get_object_type(property) === "function") {
          property = property.call(object);
        }
      }
      return property.toString();
    },
    clone: function clone(obj) {
      if (obj == null || "object" !== this.get_object_type(obj)) {
        return obj;
      }
      var copy = obj.constructor();
      Object.keys(obj).forEach(function (key) {
        var attr = obj[key];copy[key] = attr;
      });
      return copy;
    },
    merge: function merge() {
      for (var _len = arguments.length, xs = Array(_len), _key = 0; _key < _len; _key++) {
        xs[_key] = arguments[_key];
      }
      var tap = function tap(o, fn) {
        fn(o);return o;
      };
      if ((xs != null ? xs.length : undefined) > 0) {
        return tap({}, function (m) {
          return xs.map(function (x) {
            var result = [];
            for (var k in x) {
              var v = x[k];
              result.push(m[k] = v);
            }
            return result;
          });
        });
      }
    },
    normalize_options: function normalize_options(parts, required_parts, default_options, actual_parameters) {
      var _this2 = this;
      var options = this.extract_options(parts.length, actual_parameters);
      if (actual_parameters.length > parts.length) {
        throw new Error("Too many parameters provided for path");
      }
      var use_all_parts = DeprecatedBehavior || actual_parameters.length > required_parts.length;
      var parts_options = {};
      Object.keys(options).forEach(function (key) {
        var value = options[key];
        use_all_parts = true;
        if (_this2.indexOf(parts, key) >= 0) {
          parts_options[key] = value;
        }
      });
      options = this.merge(this.configuration.default_url_options, default_options, options);
      var result = {};
      var url_parameters = {};
      result['url_parameters'] = url_parameters;
      Object.keys(options).forEach(function (key) {
        var value = options[key];
        if (_this2.indexOf(ReservedOptions, key) >= 0) {
          result[key] = value;
        } else {
          url_parameters[key] = value;
        }
      });
      var route_parts = use_all_parts ? parts : required_parts;
      var i = 0;
      route_parts.forEach(function (part) {
        if (i < actual_parameters.length) {
          if (!parts_options.hasOwnProperty(part)) {
            url_parameters[part] = actual_parameters[i];
            ++i;
          }
        }
      });
      return result;
    },
    build_route: function build_route(parts, required_parts, default_options, route, full_url, args) {
      var url_params = void 0;
      args = Array.prototype.slice.call(args);
      var options = this.normalize_options(parts, required_parts, default_options, args);
      var parameters = options['url_parameters'];
      var result = '' + this.get_prefix() + this.visit(route, parameters);
      var url = Utils.clean_path(result);
      if (options['trailing_slash'] === true) {
        url = url.replace(/(.*?)[\/]?$/, "$1/");
      }
      if ((url_params = this.serialize(parameters)).length) {
        url += '?' + url_params;
      }
      url += options.anchor ? '#' + options.anchor : "";
      if (full_url) {
        url = this.route_url(options) + url;
      }
      return url;
    },
    visit: function visit(route, parameters) {
      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var type = route[0],
          left = route[1],
          right = route[2];
      switch (type) {
        case NodeTypes.GROUP:
          return this.visit(left, parameters, true);
        case NodeTypes.STAR:
          return this.visit_globbing(left, parameters, true);
        case NodeTypes.LITERAL:case NodeTypes.SLASH:case NodeTypes.DOT:
          return left;
        case NodeTypes.CAT:
          var left_part = this.visit(left, parameters, optional);
          var right_part = this.visit(right, parameters, optional);
          if (optional && (this.is_optional_node(left[0]) && !left_part || this.is_optional_node(right[0]) && !right_part)) {
            return "";
          }
          return '' + left_part + right_part;
        case NodeTypes.SYMBOL:
          var value = parameters[left];
          if (value != null) {
            delete parameters[left];
            return this.path_identifier(value);
          }
          if (optional) {
            return "";
          } else {
            throw new ParameterMissing('Route parameter missing: ' + left);
          }
        default:
          throw new Error("Unknown Rails node type");
      }
    },
    is_optional_node: function is_optional_node(node) {
      return this.indexOf([NodeTypes.STAR, NodeTypes.SYMBOL, NodeTypes.CAT], node) >= 0;
    },
    build_path_spec: function build_path_spec(route) {
      var wildcard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var type = route[0],
          left = route[1],
          right = route[2];
      switch (type) {
        case NodeTypes.GROUP:
          return '(' + this.build_path_spec(left) + ')';
        case NodeTypes.CAT:
          return '' + this.build_path_spec(left) + this.build_path_spec(right);
        case NodeTypes.STAR:
          return this.build_path_spec(left, true);
        case NodeTypes.SYMBOL:
          if (wildcard === true) {
            return '' + (left[0] === '*' ? '' : '*') + left;
          } else {
            return ':' + left;
          }
        case NodeTypes.SLASH:case NodeTypes.DOT:case NodeTypes.LITERAL:
          return left;
        default:
          throw new Error("Unknown Rails node type");
      }
    },
    visit_globbing: function visit_globbing(route, parameters, optional) {
      var type = route[0],
          left = route[1],
          right = route[2];
      if (left.replace(/^\*/i, "") !== left) {
        route[1] = left = left.replace(/^\*/i, "");
      }
      var value = parameters[left];
      if (value == null) {
        return this.visit(route, parameters, optional);
      }
      switch (this.get_object_type(value)) {
        case "array":
          parameters[left] = value.join("/");
          break;
        default:
          parameters[left] = value;
          break;
      }
      return this.visit(route, parameters, optional);
    },
    get_prefix: function get_prefix() {
      var prefix = this.configuration.prefix;
      if (prefix !== "") {
        prefix = prefix.match("/$") ? prefix : prefix + '/';
      }
      return prefix;
    },
    route: function route(parts_table, default_options, route_spec, full_url) {
      var required_parts = [];
      var parts = [];
      parts_table.forEach(function (_ref) {
        var part = _ref[0],
            required = _ref[1];
        parts.push(part);
        if (required) {
          required_parts.push(part);
        }
      });
      var path_fn = function path_fn() {
        return Utils.build_route(parts, required_parts, default_options, route_spec, full_url, arguments);
      };
      path_fn.required_params = required_parts;
      path_fn.toString = function () {
        return Utils.build_path_spec(route_spec);
      };
      return path_fn;
    },
    route_url: function route_url(route_defaults) {
      if (typeof route_defaults === 'string') {
        return route_defaults;
      }
      var hostname = route_defaults.host || Utils.current_host();
      if (!hostname) {
        return '';
      }
      var subdomain = route_defaults.subdomain ? route_defaults.subdomain + '.' : '';
      var protocol = route_defaults.protocol || Utils.current_protocol();
      var port = route_defaults.port || (!route_defaults.host ? Utils.current_port() : undefined);
      port = port ? ':' + port : '';
      return protocol + "://" + subdomain + hostname + port;
    },
    has_location: function has_location() {
      return (typeof window !== 'undefined' && window !== null ? window.location : undefined) != null;
    },
    current_host: function current_host() {
      if (this.has_location()) {
        return window.location.hostname;
      } else {
        return null;
      }
    },
    current_protocol: function current_protocol() {
      if (this.has_location() && window.location.protocol !== '') {
        return window.location.protocol.replace(/:$/, '');
      } else {
        return 'http';
      }
    },
    current_port: function current_port() {
      if (this.has_location() && window.location.port !== '') {
        return window.location.port;
      } else {
        return '';
      }
    },
    _classToTypeCache: null,
    _classToType: function _classToType() {
      var _this3 = this;
      if (this._classToTypeCache != null) {
        return this._classToTypeCache;
      }
      this._classToTypeCache = {};
      "Boolean Number String Function Array Date RegExp Object Error".split(" ").forEach(function (name) {
        _this3._classToTypeCache['[object ' + name + ']'] = name.toLowerCase();
      });
      return this._classToTypeCache;
    },
    get_object_type: function get_object_type(obj) {
      if (typeof jQuery !== 'undefined' && jQuery.type != null) {
        return jQuery.type(obj);
      }
      if (obj == null) {
        return '' + obj;
      }
      if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === "object" || typeof obj === "function") {
        return this._classToType()[Object.prototype.toString.call(obj)] || "object";
      } else {
        return typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
      }
    },
    indexOf: function indexOf(array, element) {
      if (Array.prototype.indexOf) {
        return array.indexOf(element);
      } else {
        return this.indexOfImplementation(array, element);
      }
    },
    indexOfImplementation: function indexOfImplementation(array, element) {
      var result = -1;
      for (var i = 0; i < array.length; i++) {
        var el = array[i];if (el === element) {
          result = i;
        }
      }
      return result;
    },
    configure: function configure(new_config) {
      return this.configuration = this.merge(this.configuration, new_config);
    },
    config: function config() {
      return this.clone(this.configuration);
    },
    make: function make() {
      var routes = ROUTES;
      routes.configure = function (config) {
        return Utils.configure(config);
      };
      routes.config = function () {
        return Utils.config();
      };
      Object.defineProperty(routes, 'defaults', {
        get: function get$$1() {
          throw new Error(NAMESPACE + '.defaults is removed. Use ' + NAMESPACE + '.configure() instead.');
        },
        set: function set$$1(value) {}
      });
      routes.default_serializer = function (object, prefix) {
        return Utils.default_serializer(object, prefix);
      };
      return routes;
    }
  };
  var routesSrc = Utils.make();

  return routesSrc;

})));
