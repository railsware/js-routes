/*
File generated by js-routes RubyVariables.GEM_VERSION
Based on Rails RubyVariables.RAILS_VERSION routes of RubyVariables.APP_CLASS
 */
(function (that) {
    let NodeTypes;
    (function (NodeTypes) {
        NodeTypes[NodeTypes["GROUP"] = 1] = "GROUP";
        NodeTypes[NodeTypes["CAT"] = 2] = "CAT";
        NodeTypes[NodeTypes["SYMBOL"] = 3] = "SYMBOL";
        NodeTypes[NodeTypes["OR"] = 4] = "OR";
        NodeTypes[NodeTypes["STAR"] = 5] = "STAR";
        NodeTypes[NodeTypes["LITERAL"] = 6] = "LITERAL";
        NodeTypes[NodeTypes["SLASH"] = 7] = "SLASH";
        NodeTypes[NodeTypes["DOT"] = 8] = "DOT";
    })(NodeTypes || (NodeTypes = {}));
    const Root = typeof exports === "object" ? exports : that;
    class ParameterMissing extends Error {
        constructor(message) {
            super(message);
            Object.setPrototypeOf(this, Object.getPrototypeOf(this));
        }
    }
    const DeprecatedGlobbingBehavior = RubyVariables.DEPRECATED_GLOBBING_BEHAVIOR;
    const SpecialOptionsKey = RubyVariables.SPECIAL_OPTIONS_KEY;
    const UriEncoderSegmentRegex = /[^a-zA-Z0-9\-\._~!\$&'\(\)\*\+,;=:@]/g;
    const ReservedOptions = [
        "anchor",
        "trailing_slash",
        "subdomain",
        "host",
        "port",
        "protocol",
    ];
    const DefaultConfiguration = {
        prefix: RubyVariables.PREFIX,
        default_url_options: RubyVariables.DEFAULT_URL_OPTIONS,
        special_options_key: RubyVariables.SPECIAL_OPTIONS_KEY,
        serializer: RubyVariables.SERIALIZER,
    };
    class UtilsClass {
        constructor() {
            this.configuration = DefaultConfiguration;
            this._classToTypeCache = "Boolean Number String Function Array Date RegExp Object Error"
                .split(" ")
                .reduce((result, name) => ({
                ...result,
                [`[object ${name}]`]: name.toLowerCase(),
            }), {});
        }
        default_serializer(object, prefix) {
            if (object == null) {
                return "";
            }
            if (!prefix && !(this.get_object_type(object) === "object")) {
                throw new Error("Url parameters should be a javascript hash");
            }
            const result = [];
            switch (this.get_object_type(object)) {
                case "array":
                    for (const element of object) {
                        result.push(this.default_serializer(element, prefix + "[]"));
                    }
                    break;
                case "object":
                    for (let key in object) {
                        if (!object.hasOwnProperty(key))
                            continue;
                        let prop = object[key];
                        if (prop == null && prefix) {
                            prop = "";
                        }
                        if (prop != null) {
                            if (prefix) {
                                key = prefix + "[" + key + "]";
                            }
                            result.push(this.default_serializer(prop, key));
                        }
                    }
                    break;
                default:
                    if (object != null) {
                        result.push(encodeURIComponent(prefix.toString()) +
                            "=" +
                            encodeURIComponent(object.toString()));
                    }
            }
            return result.join("&");
        }
        serialize(object) {
            const custom_serializer = this.configuration.serializer;
            if (custom_serializer) {
                return custom_serializer(object);
            }
            else {
                return this.default_serializer(object);
            }
        }
        extract_options(number_of_params, args) {
            const last_el = args[args.length - 1];
            if ((args.length > number_of_params && last_el === void 0) ||
                (last_el != null &&
                    "object" === this.get_object_type(last_el) &&
                    !this.looks_like_serialized_model(last_el))) {
                const options = args.pop() || {};
                delete options[this.configuration.special_options_key];
                return options;
            }
            else {
                return {};
            }
        }
        looks_like_serialized_model(object) {
            return (!object[this.configuration.special_options_key] &&
                ("id" in object || "to_param" in object));
        }
        path_identifier(object) {
            if (object === 0) {
                return "0";
            }
            if (!object) {
                return "";
            }
            let result = object;
            if (this.get_object_type(object) === "object") {
                if ("to_param" in object) {
                    if (object.to_param == null) {
                        throw new ParameterMissing("Route parameter missing: to_param");
                    }
                    result = object.to_param;
                }
                else if ("id" in object) {
                    if (object.id == null) {
                        throw new ParameterMissing("Route parameter missing: id");
                    }
                    result = object.id;
                }
                else {
                    result = object;
                }
                if (this.get_object_type(result) === "function") {
                    result = result.call(object);
                }
            }
            return result.toString();
        }
        normalize_options(parts, required_parts, default_options, call_arguments) {
            call_arguments = [...call_arguments];
            let options = this.extract_options(parts.length, call_arguments);
            if (call_arguments.length > parts.length) {
                throw new Error("Too many parameters provided for path");
            }
            let use_all_parts = call_arguments.length > required_parts.length;
            const parts_options = {};
            for (const key in options) {
                const value = options[key];
                if (!options.hasOwnProperty(key))
                    continue;
                use_all_parts = true;
                if (parts.includes(key)) {
                    parts_options[key] = value;
                }
            }
            options = {
                ...this.configuration.default_url_options,
                ...default_options,
                ...options,
            };
            const result = {};
            const url_parameters = {};
            result["url_parameters"] = url_parameters;
            for (const key in options) {
                if (!options.hasOwnProperty(key))
                    continue;
                const value = options[key];
                if (ReservedOptions.includes(key)) {
                    result[key] = value;
                }
                else {
                    url_parameters[key] = value;
                }
            }
            const route_parts = use_all_parts ? parts : required_parts;
            let i = 0;
            for (const part of route_parts) {
                if (i < call_arguments.length) {
                    if (!parts_options.hasOwnProperty(part)) {
                        url_parameters[part] = call_arguments[i];
                        ++i;
                    }
                }
            }
            return result;
        }
        build_route(parts, required_parts, default_options, route, full_url, args) {
            const options = this.normalize_options(parts, required_parts, default_options, args);
            const parameters = options["url_parameters"];
            let result = this.get_prefix() + this.visit(route, parameters);
            if (options["trailing_slash"] === true) {
                result = result.replace(/(.*?)[\/]?$/, "$1/");
            }
            const url_params = this.serialize(parameters);
            if (url_params.length) {
                result += "?" + url_params;
            }
            result += options.anchor ? "#" + options.anchor : "";
            if (full_url) {
                result = this.route_url(options) + result;
            }
            return result;
        }
        visit(route, parameters, optional = false) {
            switch (route[0]) {
                case NodeTypes.GROUP:
                    return this.visit(route[1], parameters, true);
                case NodeTypes.STAR:
                    return this.visit_globbing(route[1], parameters, true);
                case NodeTypes.LITERAL:
                case NodeTypes.SLASH:
                case NodeTypes.DOT:
                    return route[1];
                case NodeTypes.CAT:
                    const [_, left, right] = route;
                    const left_part = this.visit(left, parameters, optional);
                    const right_part = this.visit(right, parameters, optional);
                    if (optional &&
                        ((this.is_optional_node(left[0]) && !left_part) ||
                            (this.is_optional_node(right[0]) && !right_part))) {
                        return "";
                    }
                    return left_part + right_part;
                case NodeTypes.SYMBOL:
                    const key = route[1];
                    const value = parameters[key];
                    delete parameters[key];
                    if (value != null) {
                        return this.encode_segment(this.path_identifier(value));
                    }
                    if (optional) {
                        return "";
                    }
                    else {
                        throw new ParameterMissing("Route parameter missing: " + key);
                    }
                    break;
                default:
                    throw new Error("Unknown Rails node type");
            }
        }
        encode_segment(segment) {
            return segment.replace(UriEncoderSegmentRegex, function (str) {
                return encodeURIComponent(str);
            });
        }
        is_optional_node(node) {
            return ([NodeTypes.STAR, NodeTypes.SYMBOL, NodeTypes.CAT].includes(node));
        }
        build_path_spec(route, wildcard = false) {
            switch (route[0]) {
                case NodeTypes.GROUP:
                    return "(" + this.build_path_spec(route[1]) + ")";
                case NodeTypes.CAT:
                    return (this.build_path_spec(route[1]) + this.build_path_spec(route[2]));
                case NodeTypes.STAR:
                    return this.build_path_spec(route[1], true);
                case NodeTypes.SYMBOL:
                    const key = route[1];
                    if (wildcard === true) {
                        return (key.startsWith("*") ? "" : "*") + key;
                    }
                    else {
                        return ":" + key;
                    }
                    break;
                case NodeTypes.SLASH:
                case NodeTypes.DOT:
                case NodeTypes.LITERAL:
                    return route[1];
                default:
                    throw new Error("Unknown Rails node type");
            }
        }
        visit_globbing(route, parameters, optional) {
            const key = route[1];
            let value = parameters[key];
            delete parameters[key];
            if (value == null) {
                return this.visit(route, parameters, optional);
            }
            if (this.get_object_type(value) === "array") {
                value = value.join("/");
            }
            if (DeprecatedGlobbingBehavior) {
                return this.path_identifier(value);
            }
            else {
                return encodeURI(this.path_identifier(value));
            }
        }
        get_prefix() {
            const prefix = this.configuration.prefix;
            return prefix.match("/$") ? prefix.substring(0, prefix.length - 1) : prefix;
        }
        route(parts_table, default_options, route_spec, full_url) {
            const required_parts = [];
            const parts = [];
            for (const [part, required] of parts_table) {
                parts.push(part);
                if (required) {
                    required_parts.push(part);
                }
            }
            const result = (...args) => {
                return this.build_route(parts, required_parts, default_options, route_spec, full_url, args);
            };
            result.required_params = required_parts;
            result.toString = () => {
                return this.build_path_spec(route_spec);
            };
            return result;
        }
        route_url(route_defaults) {
            const hostname = route_defaults.host || this.current_host();
            if (!hostname) {
                return "";
            }
            const subdomain = route_defaults.subdomain
                ? route_defaults.subdomain + "."
                : "";
            const protocol = route_defaults.protocol || this.current_protocol();
            let port = route_defaults.port ||
                (!route_defaults.host ? this.current_port() : undefined);
            port = port ? ":" + port : "";
            return protocol + "://" + subdomain + hostname + port;
        }
        has_location() {
            return (typeof window !== "undefined" && window !== null && !!window.location);
        }
        current_host() {
            if (this.has_location()) {
                return window.location.hostname;
            }
            else {
                return null;
            }
        }
        current_protocol() {
            if (this.has_location() && window.location.protocol !== "") {
                return window.location.protocol.replace(/:$/, "");
            }
            else {
                return "http";
            }
        }
        current_port() {
            if (this.has_location() && window.location.port !== "") {
                return window.location.port;
            }
            else {
                return "";
            }
        }
        get_object_type(obj) {
            if (obj == null) {
                return "" + obj;
            }
            if (typeof obj === "object" || typeof obj === "function") {
                return (this._classToTypeCache[Object.prototype.toString.call(obj)] ||
                    "object");
            }
            else {
                return typeof obj;
            }
        }
        namespace(object, namespace, routes) {
            const parts = namespace ? namespace.split(".") : [];
            if (parts.length === 0) {
                return routes;
            }
            for (let index = 0; index < parts.length; index++) {
                const part = parts[index];
                if (index < parts.length - 1) {
                    object = object[part] || (object[part] = {});
                }
                else {
                    return (object[part] = routes);
                }
            }
        }
        configure(new_config) {
            this.configuration = { ...this.configuration, ...new_config };
            return this.configuration;
        }
        config() {
            return { ...this.configuration };
        }
        make() {
            const routes = {
                ...RubyVariables.ROUTES,
                configure: (config) => {
                    return this.configure(config);
                },
                config: () => {
                    return this.config();
                },
                default_serializer: (object, prefix = "") => {
                    return this.default_serializer(object, prefix);
                },
            };
            this.namespace(Root, RubyVariables.NAMESPACE, routes);
            return Object.assign({
                default: routes,
            }, routes);
        }
    }
    const Utils = new UtilsClass();
    const result = Utils.make();
    if (typeof define === "function" && define.amd) {
        define([], function () {
            return result;
        });
    }
    return result;
})(this);
//# sourceMappingURL=routes.js.map