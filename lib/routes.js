/*
File generated by js-routes RubyVariables.GEM_VERSION
Based on Rails RubyVariables.RAILS_VERSION routes of RubyVariables.APP_CLASS
 */
(function (that) {
  const hasProp = (object, key) =>
    Object.prototype.hasOwnProperty.call(object, key);
  let NodeTypes;
  (function (NodeTypes) {
    NodeTypes[(NodeTypes["GROUP"] = 1)] = "GROUP";
    NodeTypes[(NodeTypes["CAT"] = 2)] = "CAT";
    NodeTypes[(NodeTypes["SYMBOL"] = 3)] = "SYMBOL";
    NodeTypes[(NodeTypes["OR"] = 4)] = "OR";
    NodeTypes[(NodeTypes["STAR"] = 5)] = "STAR";
    NodeTypes[(NodeTypes["LITERAL"] = 6)] = "LITERAL";
    NodeTypes[(NodeTypes["SLASH"] = 7)] = "SLASH";
    NodeTypes[(NodeTypes["DOT"] = 8)] = "DOT";
  })(NodeTypes || (NodeTypes = {}));
  const Root = typeof exports === "object" ? exports : that;
  class ParametersMissing extends Error {
    constructor(...keys) {
      super(`Route missing required keys: ${keys.join(", ")}`);
      this.keys = keys;
      Object.setPrototypeOf(this, Object.getPrototypeOf(this));
    }
  }
  const DeprecatedGlobbingBehavior = RubyVariables.DEPRECATED_GLOBBING_BEHAVIOR;
  const UriEncoderSegmentRegex = /[^a-zA-Z0-9\-._~!$&'()*+,;=:@]/g;
  const ReservedOptions = [
    "anchor",
    "trailing_slash",
    "subdomain",
    "host",
    "port",
    "protocol",
  ];
  const DefaultConfiguration = {
    prefix: RubyVariables.PREFIX,
    default_url_options: RubyVariables.DEFAULT_URL_OPTIONS,
    special_options_key: RubyVariables.SPECIAL_OPTIONS_KEY,
    serializer: RubyVariables.SERIALIZER,
  };
  class UtilsClass {
    constructor() {
      this.configuration = DefaultConfiguration;
      this._classToTypeCache = "Boolean Number String Function Array Date RegExp Object Error"
        .split(" ")
        .reduce(
          (result, name) => ({
            ...result,
            [`[object ${name}]`]: name.toLowerCase(),
          }),
          {}
        );
    }
    default_serializer(object, prefix) {
      if (this.is_nullable(object)) {
        return "";
      }
      if (!prefix && !(this.get_object_type(object) === "object")) {
        throw new Error("Url parameters should be a javascript hash");
      }
      prefix = prefix || "";
      const result = [];
      switch (this.get_object_type(object)) {
        case "array":
          for (const element of object) {
            result.push(this.default_serializer(element, prefix + "[]"));
          }
          break;
        case "object":
          for (let key in object) {
            if (!hasProp(object, key)) continue;
            let prop = object[key];
            if (this.is_nullable(prop) && prefix) {
              prop = "";
            }
            if (this.is_not_nullable(prop)) {
              if (prefix) {
                key = prefix + "[" + key + "]";
              }
              result.push(this.default_serializer(prop, key));
            }
          }
          break;
        default:
          if (this.is_not_nullable(object)) {
            result.push(
              encodeURIComponent(prefix) + "=" + encodeURIComponent("" + object)
            );
          }
      }
      return result.join("&");
    }
    serialize(object) {
      const custom_serializer = this.configuration.serializer;
      if (custom_serializer) {
        return custom_serializer(object);
      } else {
        return this.default_serializer(object);
      }
    }
    extract_options(number_of_params, args) {
      const last_el = args[args.length - 1];
      if (
        (args.length > number_of_params && last_el === void 0) ||
        (this.is_not_nullable(last_el) &&
          "object" === this.get_object_type(last_el) &&
          !this.looks_like_serialized_model(last_el))
      ) {
        const options = args.pop() || {};
        delete options[this.configuration.special_options_key];
        return options;
      } else {
        return {};
      }
    }
    looks_like_serialized_model(object) {
      return (
        !object[this.configuration.special_options_key] &&
        ("id" in object || "to_param" in object)
      );
    }
    path_identifier(key, object) {
      if (object === 0) {
        return "0";
      }
      if (!object) {
        return "";
      }
      const result = this.unwrap_path_identifier(object);
      if (this.is_nullable(result)) {
        throw new ParametersMissing(key);
      }
      return "" + result;
    }
    unwrap_path_identifier(object) {
      let result = object;
      if (this.get_object_type(object) === "object") {
        if ("to_param" in object) {
          result = object.to_param;
        } else if ("id" in object) {
          result = object.id;
        } else {
          result = object;
        }
        return this.get_object_type(result) === "function"
          ? result.call(object)
          : result;
      } else {
        return object;
      }
    }
    partition_parameters(
      parts,
      required_params,
      default_options,
      call_arguments
    ) {
      call_arguments = [...call_arguments];
      let options = this.extract_options(parts.length, call_arguments);
      if (call_arguments.length > parts.length) {
        throw new Error("Too many parameters provided for path");
      }
      let use_all_parts = call_arguments.length > required_params.length;
      const parts_options = {};
      for (const key in options) {
        const value = options[key];
        if (!hasProp(options, key)) continue;
        use_all_parts = true;
        if (parts.includes(key)) {
          parts_options[key] = value;
        }
      }
      options = {
        ...this.configuration.default_url_options,
        ...default_options,
        ...options,
      };
      const url_parameters = {};
      const query_parameters = {};
      for (const key in options) {
        if (!hasProp(options, key)) continue;
        const value = options[key];
        if (ReservedOptions.includes(key)) {
          url_parameters[key] = value;
        } else {
          query_parameters[key] = value;
        }
      }
      const route_parts = use_all_parts ? parts : required_params;
      let i = 0;
      for (const part of route_parts) {
        if (i < call_arguments.length) {
          if (!hasProp(parts_options, part)) {
            query_parameters[part] = call_arguments[i];
            ++i;
          }
        }
      }
      return [url_parameters, query_parameters];
    }
    build_route(
      parts,
      required_params,
      default_options,
      route,
      full_url,
      args
    ) {
      const [url_parameters, query_parameters] = this.partition_parameters(
        parts,
        required_params,
        default_options,
        args
      );
      const missing_params = required_params.filter(
        (param) =>
          !hasProp(query_parameters, param) ||
          this.is_nullable(query_parameters[param])
      );
      if (missing_params.length) {
        throw new ParametersMissing(...missing_params);
      }
      let result = this.get_prefix() + this.visit(route, query_parameters);
      if (url_parameters.trailing_slash) {
        result = result.replace(/(.*?)[/]?$/, "$1/");
      }
      const url_params = this.serialize(query_parameters);
      if (url_params.length) {
        result += "?" + url_params;
      }
      result += url_parameters.anchor ? "#" + url_parameters.anchor : "";
      if (full_url) {
        result = this.route_url(url_parameters) + result;
      }
      return result;
    }
    visit(route, parameters, optional = false) {
      switch (route[0]) {
        case NodeTypes.GROUP:
          return this.visit(route[1], parameters, true);
        case NodeTypes.CAT:
          return this.visit_cat(...route, parameters, optional);
        case NodeTypes.SYMBOL:
          return this.visit_symbol(...route, parameters, optional);
        case NodeTypes.STAR:
          return this.visit_globbing(route[1], parameters, true);
        case NodeTypes.LITERAL:
        case NodeTypes.SLASH:
        case NodeTypes.DOT:
          return route[1];
        default:
          throw new Error("Unknown Rails node type");
      }
    }
    is_not_nullable(object) {
      return !this.is_nullable(object);
    }
    is_nullable(object) {
      return object === undefined || object === null;
    }
    visit_cat(type, left, right, parameters, optional) {
      const left_part = this.visit(left, parameters, optional);
      const right_part = this.visit(right, parameters, optional);
      if (
        optional &&
        ((this.is_optional_node(left[0]) && !left_part) ||
          (this.is_optional_node(right[0]) && !right_part))
      ) {
        return "";
      }
      return left_part + right_part;
    }
    visit_symbol(type, key, _, parameters, optional) {
      const value = parameters[key];
      delete parameters[key];
      if (this.is_not_nullable(value)) {
        return this.encode_segment(this.path_identifier(key, value));
      }
      if (optional) {
        return "";
      } else {
        throw new ParametersMissing(key);
      }
    }
    encode_segment(segment) {
      return segment.replace(UriEncoderSegmentRegex, function (str) {
        return encodeURIComponent(str);
      });
    }
    is_optional_node(node) {
      return [NodeTypes.STAR, NodeTypes.SYMBOL, NodeTypes.CAT].includes(node);
    }
    build_path_spec(route, wildcard = false) {
      let key;
      switch (route[0]) {
        case NodeTypes.GROUP:
          return "(" + this.build_path_spec(route[1]) + ")";
        case NodeTypes.CAT:
          return (
            this.build_path_spec(route[1]) + this.build_path_spec(route[2])
          );
        case NodeTypes.STAR:
          return this.build_path_spec(route[1], true);
        case NodeTypes.SYMBOL:
          key = route[1];
          if (wildcard) {
            return (key.startsWith("*") ? "" : "*") + key;
          } else {
            return ":" + key;
          }
          break;
        case NodeTypes.SLASH:
        case NodeTypes.DOT:
        case NodeTypes.LITERAL:
          return route[1];
        default:
          throw new Error("Unknown Rails node type");
      }
    }
    visit_globbing(route, parameters, optional) {
      const key = route[1];
      let value = parameters[key];
      delete parameters[key];
      if (this.is_nullable(value)) {
        return this.visit(route, parameters, optional);
      }
      if (this.get_object_type(value) === "array") {
        value = value.join("/");
      }
      value = this.path_identifier(key, value);
      return DeprecatedGlobbingBehavior ? value : encodeURI(value);
    }
    get_prefix() {
      const prefix = this.configuration.prefix;
      return prefix.match("/$")
        ? prefix.substring(0, prefix.length - 1)
        : prefix;
    }
    route(parts_table, default_options, route_spec, full_url) {
      const required_params = [];
      const parts = [];
      for (const [part, required] of parts_table) {
        parts.push(part);
        if (required) {
          required_params.push(part);
        }
      }
      const result = (...args) => {
        return this.build_route(
          parts,
          required_params,
          default_options,
          route_spec,
          full_url,
          args
        );
      };
      result.required_params = required_params;
      result.toString = () => {
        return this.build_path_spec(route_spec);
      };
      return result;
    }
    route_url(route_defaults) {
      const hostname = route_defaults.host || this.current_host();
      if (!hostname) {
        return "";
      }
      const subdomain = route_defaults.subdomain
        ? route_defaults.subdomain + "."
        : "";
      const protocol = route_defaults.protocol || this.current_protocol();
      let port =
        route_defaults.port ||
        (!route_defaults.host ? this.current_port() : undefined);
      port = port ? ":" + port : "";
      return protocol + "://" + subdomain + hostname + port;
    }
    has_location() {
      return this.is_not_nullable(window) && !!window.location;
    }
    current_host() {
      if (this.has_location()) {
        return window.location.hostname;
      } else {
        return null;
      }
    }
    current_protocol() {
      if (this.has_location() && window.location.protocol !== "") {
        return window.location.protocol.replace(/:$/, "");
      } else {
        return "http";
      }
    }
    current_port() {
      if (this.has_location() && window.location.port !== "") {
        return window.location.port;
      } else {
        return "";
      }
    }
    get_object_type(obj) {
      if (obj == null) {
        return "" + obj;
      }
      if (typeof obj === "object" || typeof obj === "function") {
        return (
          this._classToTypeCache[Object.prototype.toString.call(obj)] ||
          "object"
        );
      } else {
        return typeof obj;
      }
    }
    namespace(object, namespace, routes) {
      const parts = namespace ? namespace.split(".") : [];
      if (parts.length === 0) {
        return routes;
      }
      for (let index = 0; index < parts.length; index++) {
        const part = parts[index];
        if (index < parts.length - 1) {
          object = object[part] || (object[part] = {});
        } else {
          return (object[part] = routes);
        }
      }
    }
    configure(new_config) {
      this.configuration = { ...this.configuration, ...new_config };
      return this.configuration;
    }
    config() {
      return { ...this.configuration };
    }
    make() {
      const routes = {
        ...RubyVariables.ROUTES,
        configure: (config) => {
          return this.configure(config);
        },
        config: () => {
          return this.config();
        },
        default_serializer: (object) => {
          return this.default_serializer(object);
        },
      };
      this.namespace(Root, RubyVariables.NAMESPACE, routes);
      return Object.assign(
        {
          default: routes,
        },
        routes
      );
    }
  }
  const Utils = new UtilsClass();
  const result = Utils.make();
  if (typeof define === "function" && define.amd) {
    define([], function () {
      return result;
    });
  }
  return result;
})(this);
//# sourceMappingURL=routes.js.map
