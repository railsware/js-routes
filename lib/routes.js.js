/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * DS208: Avoid top-level this
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
/*
File generated by js-routes GEM_VERSION
Based on Rails routes of APP_CLASS
*/
// root is this
const root = (typeof exports !== 'undefined' && exports !== null ? exports : this);

var ParameterMissing = function(message, fileName, lineNumber) {
  const instance = new Error(message, fileName, lineNumber);
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
  } else {
    instance.__proto__ = this.__proto__;
  }
  if (Error.captureStackTrace) {
    Error.captureStackTrace(instance, ParameterMissing);
  }
  return instance;
};

ParameterMissing.prototype = Object.create(Error.prototype, { constructor: {
  value: Error,
  enumerable: false,
  writable: true,
  configurable: true
}
}
);

if (Object.setPrototypeOf) {
  Object.setPrototypeOf(ParameterMissing, Error);
} else {
  ParameterMissing.__proto__ = Error;
}

const NodeTypes = NODE_TYPES;
const SpecialOptionsKey = SPECIAL_OPTIONS_KEY;
const DeprecatedBehavior = DEPRECATED_BEHAVIOR;

const ReservedOptions = [
  'anchor',
  'trailing_slash',
  'subdomain',
  'host',
  'port',
  'protocol'
];

var Utils = {

  configuration: {
    prefix: PREFIX,
    default_url_options: DEFAULT_URL_OPTIONS,
    special_options_key: SPECIAL_OPTIONS_KEY,
    serializer: SERIALIZER
  },


  default_serializer(object, prefix = null) {
    if (object == null) { return ""; }
    if (!prefix && !(this.get_object_type(object) === "object")) {
      throw new Error("Url parameters should be a javascript hash");
    }

    const s = [];
    switch (this.get_object_type(object)) {
      case "array":
        for (let i = 0; i < object.length; i++) {
          const element = object[i];
          s.push(this.default_serializer(element, prefix + "[]"));
        }
        break;
      case "object":
        for (let key of Object.keys(object)) {
          let prop = object[key];
          if ((prop == null) && (prefix != null)) {
            prop = "";
          }

          if (prop != null) {
            if (prefix != null) { key = `${prefix}[${key}]`; }
            s.push(this.default_serializer(prop, key));
          }
        }
        break;
      default:
        if (object != null) {
          s.push(`${encodeURIComponent(prefix.toString())}=${encodeURIComponent(object.toString())}`);
        }
    }

    if (!s.length) { return ""; }
    return s.join("&");
  },

  serialize(object) {
    const custom_serializer = this.configuration.serializer;
    if ((custom_serializer != null) && (this.get_object_type(custom_serializer) === "function")) {
      return custom_serializer(object);
    } else {
      return this.default_serializer(object);
    }
  },

  clean_path(path) {
    path = path.split("://");
    const last_index = path.length - 1;
    path[last_index] = path[last_index].replace(/\/+/g, "/");
    return path.join("://");
  },

  extract_options(number_of_params, args) {
    const last_el = args[args.length - 1];
    if (((args.length > number_of_params) && (last_el === undefined)) || ((last_el != null) && ("object" === this.get_object_type(last_el)) && !this.looks_like_serialized_model(last_el))) {
      const options = args.pop() || {};
      delete options[this.configuration.special_options_key];
      return options;
    } else {
      return {};
    }
  },

  looks_like_serialized_model(object) {
    return !object[this.configuration.special_options_key] && ("id" in object || "to_param" in object);
  },


  path_identifier(object) {
    if (object === 0) { return "0"; }
    // null, undefined, false or ''
    if (!object) { return ""; }
    let property = object;
    if (this.get_object_type(object) === "object") {
      if ("to_param" in object) {
        if (object.to_param == null) { throw new ParameterMissing("Route parameter missing: to_param"); }
        property = object.to_param;
      } else if ("id" in object) {
        if (object.id == null) { throw new ParameterMissing("Route parameter missing: id"); }
        property = object.id;
      } else {
        property = object;
      }

      if (this.get_object_type(property) === "function") { property = property.call(object); }
    }
    return property.toString();
  },

  clone(obj) {
    if ((obj == null) || ("object" !== this.get_object_type(obj))) { return obj; }
    const copy = obj.constructor();
    for (let key of Object.keys(obj)) { const attr = obj[key]; copy[key] = attr; }
    return copy;
  },

  merge(...xs) {
    const tap = function(o, fn) { fn(o); return o; };
    if ((xs != null ? xs.length : undefined) > 0) {
      return tap({}, m => xs.map((x) => {
        const result = [];
        for (let k in x) {
          const v = x[k];
          result.push(m[k] = v);
        }
        return result;
      }));
    }
  },

  normalize_options(parts, required_parts, default_options, actual_parameters) {
    let options = this.extract_options(parts.length, actual_parameters);

    if (actual_parameters.length > parts.length) {
      throw new Error("Too many parameters provided for path");
    }

    let use_all_parts = DeprecatedBehavior || (actual_parameters.length > required_parts.length);
    const parts_options = {};

    for (var key of Object.keys(options)) {
      use_all_parts = true;
      if (this.indexOf(parts, key) >= 0) {
        parts_options[key] = value;
      }
    }

    options = this.merge(this.configuration.default_url_options, default_options, options);
    const result = {};
    const url_parameters = {};
    result['url_parameters'] = url_parameters;
    for (key of Object.keys(options)) {
      var value = options[key];
      if (this.indexOf(ReservedOptions, key) >= 0) {
        result[key] = value;
      } else {
        url_parameters[key] = value;
      }
    }

    const route_parts = use_all_parts ? parts : required_parts;
    let i = 0;
    for (let part of route_parts) {
      if (i < actual_parameters.length) {
        if (!parts_options.hasOwnProperty(part)) {
          url_parameters[part] = actual_parameters[i];
          ++i;
        }
      }
    }

    return result;
  },

  build_route(parts, required_parts, default_options, route, full_url, args) {
    let url_params;
    args = Array.prototype.slice.call(args);

    const options = this.normalize_options(parts, required_parts, default_options, args);
    const parameters = options['url_parameters'];

    // path
    const result = `${this.get_prefix()}${this.visit(route, parameters)}`;
    let url = Utils.clean_path(result);
    // set trailing_slash
    if (options['trailing_slash'] === true) { url = url.replace(/(.*?)[\/]?$/, "$1/"); }
    // set additional url params
    if ((url_params = this.serialize(parameters)).length) {
      url += `?${url_params}`;
    }
    // set anchor
    url += options.anchor ? `#${options.anchor}` : "";
    if (full_url) {
      url = this.route_url(options) + url;
    }
    return url;
  },

  //
  // This function is JavaScript impelementation of the
  // Journey::Visitors::Formatter that builds route by given parameters
  // from route binary tree.
  // Binary tree is serialized in the following way:
  // [node type, left node, right node ]
  //
  // @param  {Boolean} optional  Marks the currently visited branch as optional.
  // If set to `true`, this method will not throw when encountering
  // a missing parameter (used in recursive calls).
  //
  visit(route, parameters, optional = false) {
    const [type, left, right] = route;
    switch (type) {
      case NodeTypes.GROUP:
        return this.visit(left, parameters, true);
      case NodeTypes.STAR:
        return this.visit_globbing(left, parameters, true);
      case NodeTypes.LITERAL: case NodeTypes.SLASH: case NodeTypes.DOT:
        return left;
      case NodeTypes.CAT:
        var left_part = this.visit(left, parameters, optional);
        var right_part = this.visit(right, parameters, optional);
        if (optional && ((this.is_optional_node(left[0]) && !left_part) ||
                                     ((this.is_optional_node(right[0])) && !right_part))) {
          return "";
        }
        return `${left_part}${right_part}`;
      case NodeTypes.SYMBOL:
        var value = parameters[left];
        if (value != null) {
          delete parameters[left];
          return this.path_identifier(value);
        }
        if (optional) {
          return ""; // missing parameter
        } else {
          throw new ParameterMissing(`Route parameter missing: ${left}`);
        }
      //
      // I don't know what is this node type
      // Please send your PR if you do
      //
      // when NodeTypes.OR:
      default:
        throw new Error("Unknown Rails node type");
    }
  },


  is_optional_node(node) { return this.indexOf([NodeTypes.STAR, NodeTypes.SYMBOL, NodeTypes.CAT], node) >= 0; },

  //
  // This method build spec for route
  //
  build_path_spec(route, wildcard=false) {
    const [type, left, right] = route;
    switch (type) {
      case NodeTypes.GROUP:
        return `(${this.build_path_spec(left)})`;
      case NodeTypes.CAT:
        return `${this.build_path_spec(left)}${this.build_path_spec(right)}`;
      case NodeTypes.STAR:
        return this.build_path_spec(left, true);
      case NodeTypes.SYMBOL:
        if (wildcard === true) {
          return `${left[0] === '*' ? '' : '*'}${left}`;
        } else {
          return `:${left}`;
        }
      case NodeTypes.SLASH: case NodeTypes.DOT: case NodeTypes.LITERAL:
        return left;
      // Not sure about this one
      // when NodeTypes.OR
      default: throw new Error("Unknown Rails node type");
    }
  },

  //
  // This method convert value for globbing in right value for rails route
  //
  visit_globbing(route, parameters, optional) {
    let [type, left, right] = route;
    // fix for rails 4 globbing
    if (left.replace(/^\*/i, "") !== left) { route[1] = (left = left.replace(/^\*/i, "")); }
    const value = parameters[left];
    if (value == null) { return this.visit(route, parameters, optional); }
    switch (this.get_object_type(value)) {
      case "array":
        parameters[left] = value.join("/");
        break;
      default:
        parameters[left] = value;
        break;
    }
    return this.visit(route, parameters, optional);
  },

  //
  // This method check and return prefix from options
  //
  get_prefix() {
    let { prefix } = this.configuration;
    if (prefix !== "") { prefix = (prefix.match("/$") ? prefix : `${prefix}/`); }
    return prefix;
  },

  //
  // route function: create route path function and add spec to it
  //
  route(parts_table, default_options, route_spec, full_url) {
    const required_parts = [];
    const parts = [];
    for (let [part, required] of parts_table) {
      parts.push(part);
      if (required) { required_parts.push(part); }
    }

    const path_fn = function() { return Utils.build_route(
      parts, required_parts, default_options, route_spec, full_url, arguments
    ); };
    path_fn.required_params = required_parts;
    path_fn.toString = () => Utils.build_path_spec(route_spec);
    return path_fn;
  },


  route_url(route_defaults) {
    if (typeof route_defaults === 'string') { return route_defaults; }

    const hostname = route_defaults.host || Utils.current_host();

    if (!hostname) { return ''; }

    const subdomain = route_defaults.subdomain ? route_defaults.subdomain + '.' : '';
    const protocol = route_defaults.protocol || Utils.current_protocol();
    let port = route_defaults.port || (!route_defaults.host ? Utils.current_port() : undefined);
    port = port ? `:${port}` : '';

    return protocol + "://" + subdomain + hostname + port;
  },

  has_location() { return ((typeof window !== 'undefined' && window !== null ? window.location : undefined) != null); },

  current_host() {
    if (this.has_location()) { return window.location.hostname; } else { return null; }
  },

  current_protocol() {
    if (this.has_location() && (window.location.protocol !== '')) {
      // location.protocol includes the colon character
      return window.location.protocol.replace(/:$/, '');
    } else {
      return 'http';
    }
  },

  current_port() {
    if (this.has_location() && (window.location.port !== '')) {
      return window.location.port;
    } else {
      return '';
    }
  },

  //
  // This is helper method to define object type.
  // The typeof operator is probably the biggest design flaw of JavaScript, simply because it's basically completely broken.
  //
  // Value               Class      Type
  // -------------------------------------
  // "foo"               String     string
  // new String("foo")   String     object
  // 1.2                 Number     number
  // new Number(1.2)     Number     object
  // true                Boolean    boolean
  // new Boolean(true)   Boolean    object
  // new Date()          Date       object
  // new Error()         Error      object
  // [1,2,3]             Array      object
  // new Array(1, 2, 3)  Array      object
  // new Function("")    Function   function
  // /abc/g              RegExp     object
  // new RegExp("meow")  RegExp     object
  // {}                  Object     object
  // new Object()        Object     object
  //
  // What is why I use Object.prototype.toString() to know better type of variable. Or use jQuery.type, if it available.
  // _classToTypeCache used for perfomance cache of types map (underscore at the beginning mean private method - of course it doesn't realy private).
  //
  _classToTypeCache: null,
  _classToType() {
    if (this._classToTypeCache != null) { return this._classToTypeCache; }
    this._classToTypeCache = {};
    for (let name of "Boolean Number String Function Array Date RegExp Object Error".split(" ")) {
      this._classToTypeCache[`[object ${name}]`] = name.toLowerCase();
    }
    return this._classToTypeCache;
  },
  get_object_type(obj) {
    if (root.jQuery && (root.jQuery.type != null)) { return root.jQuery.type(obj); }
    if (obj == null) { return `${obj}`; }
    if ((typeof obj === "object") || (typeof obj === "function")) { return this._classToType()[Object.prototype.toString.call(obj)] || "object"; } else { return typeof obj; }
  },

  // indexOf helper
  indexOf(array, element) { if (Array.prototype.indexOf) { return array.indexOf(element); } else { return this.indexOfImplementation(array, element); } },
  indexOfImplementation(array, element) {
    let result = -1;
    for (let i = 0; i < array.length; i++) { const el = array[i]; if (el === element) { result = i; } }
    return result;
  },

  namespace(root, namespace, routes) {
    const parts = namespace.split(".");
    if (parts.length === 0) { return routes; }
    for (let index = 0; index < parts.length; index++) {
      const part = parts[index];
      if (index < (parts.length - 1)) {
        root = (root[part] || (root[part] = {}));
      } else {
        return root[part] = routes;
      }
    }
  },

  configure(new_config) {
    return this.configuration = this.merge(this.configuration, new_config);
  },

  config() {
    return this.clone(this.configuration);
  },

  make() {
    const routes = ROUTES;
    routes.configure = config => Utils.configure(config);
    routes.config = () => Utils.config();
    Object.defineProperty(routes, 'defaults', {
      get() {
        throw new Error(`${NAMESPACE}.defaults is removed. Use ${NAMESPACE}.configure() instead.`);
      },
      set(value) {}
    }
    );

    routes.default_serializer = (object, prefix) => Utils.default_serializer(object, prefix);
    return Utils.namespace(root, NAMESPACE, routes);
  }
};

// Set up Routes appropriately for the environment.
if ((typeof define === "function") && define.amd) {
  // AMD
  define([], () => Utils.make());
} else {
  // Browser globals
  Utils.make();
}
